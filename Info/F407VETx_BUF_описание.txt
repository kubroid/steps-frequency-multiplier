OC_DMA_BUF

краткое описание
-----------------------------
буферизированный способ умножения

основной принцип
----------------------
Каждые 1000мкс (сервоцикл) мы считаем входяшие шаги оси. 
По завершению сервоцикла считаем среднюю входную частоту.
И отправляем в выходной буффер эти данные о кол-ве шагов и частоте.
Выходной таймер подхватывает эти данные и меняет, согласно им,
свой период и предделитель. И начинает считать. С помощью OC+DMA
каждую итерацию таймер дёргает выходной пин.

минусы
----------------
вывод отстаёт от входа на время сервопериода.
обработка смены направления требует особой химии.




подробности отлова шагов одной оси
----------------------------------------
Основные действия идут в общем обработчике SysTick.
В начале каждого обработчика SysTick мы делаем отметку по времени.
Соответственно, мы имеет предыдущую и текущую отметки.
Разница между отметками будет примерно в 1000мкс.
Предыдущая отметка нужна для подсчета входящих частот каждой оси.
Если для любой оси кол-во шагов больше нуля, то мы считаем 
входную частоту и отправляем данные о частоте и кол-ве шагов в 
выходной буффер (массив). Если генерация шагов оси выключена - включаем.
В конце каждого обработчика SysTick кол-во подсчитанных шагов 
каждой оси сбрасывается в 0.

В 'STEP' обработчике EXTI каждой оси мы только считаем кол-во шагов.

В 'DIR' обработчике EXTI каждой оси мы прерываем подсчёт шагов.
Делаем отметку по времени и отнимаем от неё отметку, сделанную в SysTick.
Если для текущей оси кол-во шагов было больше нуля, то мы считаем 
входную частоту и отправляем данные о частоте и кол-ве этих шагов 
в выходной буффер (массив). Затем в выходной буффер
отправляем данные о смене направления и задержке, которую нужно
сделать перед сменой. Если генерация шагов оси выключена - включаем.





подробности вывода шагов одной оси
----------------------------------------
Имеем для каждой оси выходной буффер (массив размером 256).
Каждый элемент массива состоит из 2-х чисел
    1-е число - кол-во шагов (1..65535) / смена направления (-1)
    2-е число - время генерации шагов / задержка до и после смены направления
Как видно элемент может содержать или данные о выходных шагах, 
или данные о смене направления оси. И в зависимости от типа данных
выходной таймер настраивается по разному.

Данные из выходного буффера используются в обработчике Update 
выходного таймера оси. 

Для генерации шагов используем связку таймера OC+DMA.
Для DMA юзаем заранее созданный массив, размер которого 
зависит от множителя и максимальной входной частоты.
Массив выглядит так [0,1,2,3,4,5,...]
Выходной пин дёргается при совпадении значения счётчика
с очередным значением из массива. За очередность отвечает DMA.

Для генерации смены направления используем OC.
В событии совпадения счетчика таймера с числом из OC
мы дёргаем выходной пин направления оси.




пример 1
-------------
Допустим, сервопериод = 1000мкс, множитель = 10,
а максимальная входная частота = 50КГц.
Массив для DMA будет размером 50*2*10 = 1000,
а выглядеть будет так [0,1,2,3,4,5,...,998,999].
Массив 2-х байтовый, так что размер в ОЗУ составит 2000 Кбайт.

За один из сервопериодов мы поймали 20 шагов.
Средняя входная частота получилась 20 * 1000 = 20000Гц (20КГц).

Настраиваем предделитель выходного таймера так,
чтобы он считал с частотой 20КГц * 2 * 10 = 400КГц.
Т.к. максимальная частота у нас 168МГц, то предделитель
будет = 168000000/400000 - 1 = 420 - 1 = 419.

Период выходного таймера ставим = 20*2*10 - 1 = 400 - 1 = 399.

Цель всех махинаций, чтобы выходной таймер досчитал 
до 400 ровно за 1000 мкс. При этом каждую итерацию он должен дёргать
выходной пин. 400 передёргиваний = 200 выходных шагов за 1000 мкс.
Т.е. шаги как положено умножатся на 10.

